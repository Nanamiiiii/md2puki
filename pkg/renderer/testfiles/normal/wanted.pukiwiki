
** tags: コンピュータ・アーキテクチャA
* コンピュータ・アーキテクチャA第二回
** Links
- 第一回: https://hackmd.io/JjhMKVgFTo6xEhsPSxHA2A
- 第4回 : https://hackmd.io/ERLnv_n_QYaK1c-oAhXEGQ
-- 第3回は実習

** 日本のスーパーコンピュータ
- 1993 スーパーコンピュータVPP500、数値風洞(NWT)
-- Hajime Miyoshi


- 地球シミュレータ
-- 地球の大気などをシミュレーションする平和利用を目的としていた


- 京
-- 10P(ぺた) FLOPS

** Saymour Cray@
- スーパーコンピュータの父
- [[シーモア・クレイ賞:https://ja.wikipedia.org/wiki/%E3%82%B7%E3%83%BC%E3%83%A2%E3%82%A2%E3%83%BB%E3%82%AF%E3%83%AC%E3%82%A4%E8%B3%9E]]
-- スーパーコンピュータ分野でもっとも権威のある賞
- 早いコンピュータは導線が短い方がいい
-- 当時の短い形が円形なのでCの字になった

** 命令セットアーキテクチャの分類(ISA)
*** 1)CPU内のオペランド・ストレージ(格納場所)
- オペランド: 命令中で使用されるデータ
- 足し算でどこどどこを足すか、みたいなやつ

*** 2)命令中で明示的に指定できるオペランド数
- 古い(単純な)コンピュータだとadd等でオペランドを指定できないものもある
-- 今はaとbを足してcに格納しなさい、のような感じ

*** 3)オペランドの場所
- オペランドがプロセッサ外、たとえばメモリ上にあってもよいか
- その場合にはオペランドをどのように指定するか。(アドレッシングモード)
-- 命令は32bit。32bitの中でどうやってメモリ上の32bitのアドレスを指定するか

*** 4)演算命令
- どのような演算命令を持っているか。
-- add、fadd(floating add、32bit、単精度)、dadd(64bit、倍精度)

*** 5)オペランドのタイプとサイズ
- 整数、浮動小数点、文字列etc

** 1)CPU内のオペランド・ストレージ
- a) スタック(Stack)アーキテクチャ
-- LIFO(Last In First Out)
- b) アキュムレータ(Accumulator)アーキテクチャ
- c) レジスタ(Register)アーキテクチャ ← 現在使用されているらしい

*** スタックアーキテクチャ
- C=A+B ()内はスタックの中身
push A (A)
push B (A,B)
add (A+B)
pop C () -> メモリ上のC番地にA+Bをストア
&ref(https://i.imgur.com/QkEhGuA.png);


- 採用されたコンピュータ: Burnough's B5500, HP 3000/70

*** Pros <ちょーしょ>
+ 逆ポーランド記法(Reversed Polish)で記述された計算を簡単に実行できる
-- ''a+b'' → ''ab+''
-- ''a*b'' → ''ab*''
-- ''a+b*c'' → ''abc*+''
-- ''a*b+c'' → ''ab*c+''
-- ''(a+b)*c'' → ''ab+c*''
-- ''(a+b)*(c+d)'' → ''ab+cd+*''
-- 例　''e=(a+b)*(c+d)''
--- push a (a)
--- push b (a, b)
--- add (a+b)
--- push c (a+b, c)
--- push d (a+b, c, d)
--- add (a+b, c+d)
--- mul ((a+b)*(c+d))
--- pop e () # メモリ上のeに取り出し


+ 命令の長さが短く、ハードウェアを簡単に作れる

*** Cons
- スタック中のデータへのランダムなアクセスができない
-- →プログラム実行効率が良くない

** 演習
- 日付、学生番号、氏名
- ''e=a+(b+c)*d'' に関して
++ 逆ポーランド記法で記述する
++ スタックアーキテクチャでの命令の列を書く
++ スタックの状態を図示する
